"""Collect MCMC proposal densities

"""

import numpy as np

class ProposalDensity(object):
    """A proposal density for a local-random-walk Markov chain sampler."""

    def evaluate(x, y):
        """Evaluate log of the density to propose ``x`` given ``y``, log(q(x|y)).

        :param x:

            The proposed point.

        :param y:

            The current point of the Markov chain.

        """
        raise NotImplementedError()

    def propose(y, rng):
        """Propose a new point given ``y`` using the random number
        generator ``rng``

        :param y:

            The current position of the chain.

        :param rng:

            The state of a random number generator like numpy.random.mtrand

        """
        raise NotImplementedError()

class AdaptiveProposal(ProposalDensity):
    """Abstract proposal density with adaptation"""

    def adapt(points):
        """Adapt the proposal function based on a sequence of chain
        samples.

        :param points:

            An iterable of points from the chain in the order
            generated by the chain.

        """
        raise NotImplementedError()

class Multivariate(AdaptiveProposal):
    """A multivariate proposal density with covariance adaptation and
    rescaling

    """
    pass

class MultivariateGaussian(Multivariate):
    """A multivariate Gaussian density with covariance adaptation and rescaling

    :param mu:

         A numpy array of the mean values.

    :param sigma:

         A numpy array representing the covariance-matrix.

    """

    def __init__(self, mu, sigma):
        self.mu    = mu.copy()
        self.dim   = len(mu)
        self.sigma = sigma.copy()

        self._sigmaDecompose()

    def _sigmaDecompose(self):
        """Private function to calculate the Cholesky decomposition, the
        inverse and the normalisation of the covariance matrix sigma and
        store it in the object instance

        """
        self.choleskySigma    =  np.linalg.cholesky(self.sigma)
        self.invSigma         =  np.linalg.inv(self.sigma)
        self.logNormalisation = -.5 * self.dim * np.log(2*np.pi) + .5 * np.log(np.linalg.det(self.invSigma))

    def evaluate(self, x , y):
        """Evaluate log of the density to propose ``x`` given ``y``, log(q(x|y)).

        :param x:

            The proposed point.

        :param y:

            The current point of the Markov chain.

        """
        return self.logNormalisation - .5 * np.dot(np.dot(x-y,self.invSigma),x-y)

    def propose(self, y, rng):
        """Propose a new point given ``y`` using the random number
        generator ``rng``

        :param y:

            The current position of the chain.

        :param rng:

            The state of a random number generator like numpy.random.mtrand

        """
        # Box-Muller transform to obtain samples from standard gauss
        sample = np.sqrt(-2.*np.log(np.random.rand(self.dim))) * np.cos(2.*np.pi*np.random.rand(self.dim))

        # transform sample from standard gauss
        sample = self.mu + np.dot(self.choleskySigma,sample)

        return y + sample
